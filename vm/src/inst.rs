use crate::{Bank, Ctrl};
use util::Page;

#[derive(Clone)]
pub enum Inst {
    Immediate(u8),
    Insert(u8),
    Swap,
    High,
    Low,
    Zero,
    Origin,
    Start,
    Goto,
    Jump,
    Position,
    Page,
    Left,
    Right,
    Up,
    Down,
    Inc,
    Dec,
    Add,
    Sub,
    Mul,
    Div,
    Clear,
    Raise,
    Neg,
    Bool,
    Eq,
    Lt,
    Gt,
    Not,
    And,
    Or,
    Xor,
    Shl,
    Shr,
    Rotl,
    Rotr,
    Read,
    Write,
    Delete,
    Put,
    Get,
    Save,
    Restore,
    Eval,
    Quote(String),
    Meta(Ctrl),
    Nop,
}
impl Inst {
    #[allow(clippy::match_same_arms)]
    pub fn new(key: char) -> Self {
        match key {
            '\n' => Inst::Meta(Ctrl::Enter),
            '!' => Inst::Neg,
            '"' => Inst::Meta(Ctrl::Quote),
            '#' => Inst::Meta(Ctrl::Ignore),
            '$' => Inst::Nop,
            '%' => Inst::Meta(Ctrl::While),
            '&' => Inst::And,
            '\'' => Inst::Meta(Ctrl::Direct),
            '(' => Inst::Rotl,
            ')' => Inst::Rotr,
            '*' => Inst::Mul,
            '+' => Inst::Add,
            ',' => Inst::Get,
            '-' => Inst::Sub,
            '.' => Inst::Put,
            '/' => Inst::Div,
            '0'..='9' => Inst::Insert(translate_hex_digit(key)),
            ':' => Inst::Meta(Ctrl::Call),
            ';' => Inst::Meta(Ctrl::Define),
            '<' => Inst::Lt,
            '=' => Inst::Eq,
            '>' => Inst::Gt,
            '?' => Inst::Bool,
            '@' => Inst::Meta(Ctrl::Run),
            'A'..='Z' => Inst::new(key.to_ascii_lowercase()),
            '[' => Inst::Inc,
            '\\' => Inst::Raise,
            ']' => Inst::Dec,
            '^' => Inst::Xor,
            '_' => Inst::Clear,
            '`' => Inst::Eval,
            'a'..='f' => Inst::Insert(translate_hex_digit(key)),
            'g' => Inst::Origin,
            'h' => Inst::Left,
            'i' => Inst::High,
            'j' => Inst::Down,
            'k' => Inst::Up,
            'l' => Inst::Right,
            'm' => Inst::Position,
            'n' => Inst::Page,
            'o' => Inst::Low,
            'p' => Inst::Goto,
            'q' => Inst::Meta(Ctrl::Macro),
            'r' => Inst::Read,
            's' => Inst::Start,
            't' => Inst::Restore,
            'u' => Inst::Jump,
            'v' => Inst::Save,
            'w' => Inst::Write,
            'x' => Inst::Delete,
            'y' => Inst::Swap,
            'z' => Inst::Zero,
            '{' => Inst::Shl,
            '|' => Inst::Or,
            '}' => Inst::Shr,
            '~' => Inst::Not,
            _ => Inst::Nop,
        }
    }
    pub fn issue(&self, bank: &mut Bank, page: &mut Page) {
        match *self {
            Inst::Immediate(data) => bank.imm(data),
            Inst::Insert(digit) => bank.ins(digit),
            Inst::Swap => bank.swap(),
            Inst::High => bank.hi(),
            Inst::Low => bank.lo(),
            Inst::Zero => bank.zero(),
            Inst::Origin => bank.origin(),
            Inst::Start => bank.start(),
            Inst::Goto => bank.goto(),
            Inst::Jump => bank.jump(),
            Inst::Position => bank.position(),
            Inst::Page => bank.page(),
            Inst::Left => bank.left(),
            Inst::Right => bank.right(),
            Inst::Up => bank.up(),
            Inst::Down => bank.down(),
            Inst::Inc => bank.inc(),
            Inst::Dec => bank.dec(),
            Inst::Add => bank.add(),
            Inst::Sub => bank.sub(),
            Inst::Mul => bank.mul(),
            Inst::Div => bank.div(),
            Inst::Clear => bank.clear(),
            Inst::Raise => bank.raise(),
            Inst::Neg => bank.neg(),
            Inst::Bool => bank.bool(),
            Inst::Eq => bank.eq(),
            Inst::Lt => bank.lt(),
            Inst::Gt => bank.gt(),
            Inst::Not => bank.not(),
            Inst::And => bank.and(),
            Inst::Or => bank.or(),
            Inst::Xor => bank.xor(),
            Inst::Shl => bank.shl(),
            Inst::Shr => bank.shr(),
            Inst::Rotl => bank.rotl(),
            Inst::Rotr => bank.rotr(),
            Inst::Read => bank.read(page),
            Inst::Write => update_page(&bank.write(*page), page),
            Inst::Delete => update_page(&bank.del(*page), page),
            Inst::Put => bank.put(page),
            Inst::Get => update_page(&bank.get(*page), page),
            Inst::Save => update_page(&bank.save(*page), page),
            Inst::Restore => bank.restore(page),
            Inst::Eval | Inst::Quote(_) | Inst::Meta(_) | Inst::Nop => (),
        }
    }
}

fn update_page(src: &Option<Page>, dst: &mut Page) {
    if let Some(page) = src {
        *dst = *page;
    }
}
fn translate_hex_digit(key: char) -> u8 {
    const ZERO: u8 = b'0';
    const A: u8 = b'a';
    match key {
        '0'..='9' => key as u8 - ZERO,
        'a'..='f' => key as u8 - A + 0xA,
        _ => unreachable!(),
    }
}
